<!-- markdown_py README.md > README.html -->

<h1>Prova Final - Sistemas Hardware-Software</h1>
<p>Neste prova iremos avaliar os objetivos de aprendizagem trabalhados na segunda metade do curso. Cada pasta contém os arquivos de uma questão da prova, incluindo arquivos <code>.c</code> para vocês colocarem suas soluções.</p>
<h2>Regras da prova</h2>
<ol>
<li>A prova é individual. São permitidas consultas a todos os materiais de aula, incluindo suas soluções a exercícios de aula e labs. </li>
<li>Não é permitido consultar outras pessoas, sejam do Insper ou não, durante a prova.</li>
<li>Esta prova também avalia fluência nos conceitos estudados.</li>
<li>A prova terá duração de <code>três horas</code>, com início às <strong>13:30</strong> e término às <strong>16:30</strong>. Desconsidere o tempo do proctorio.</li>
<li>A entrega da sua prova deverá ser feita via Blackboard. <strong>Não serão aceitas entregas por outros meios</strong>.</li>
<li>O item de entrega permite múltiplas tentativas. Sempre que terminar uma questão faça uma entrega completa. Isto visa minimizar problemas com entregas atrasadas.</li>
<li>Sua entrega consiste na pasta da prova inteira. Rezipe e entregue via Blackboard.</li>
<li>A chamada na prova será pela inicialização do proctorio e assinatura. Não saia sem assinar a lista.</li>
<li>Cada questão possui um arquivo específico para resposta. Não altere o nome destes arquivos.</li>
<li>Não serão tiradas dúvidas do conteúdo durante a prova.</li>
</ol>
<h2>Questão 1 (2,5)</h2>
<p>A figura <em>q1/sincronizacao.png</em> ilustra as relações de dependência entre as partes das funções <code>thread1</code>, <code>thread2</code>, <code>thread3</code> e <code>thread4</code>, mostrando que algumas delas poderiam ser feitas de maneira concorrente.</p>
<p><img alt="width:450px" src="q1/sincronizacao.png" /></p>
<p>Seu trabalho nesta questão será:</p>
<p><strong>1.</strong> criar threads para execução concorrente das funções (<strong>40% da nota</strong>)</p>
<p><strong>2.</strong> usar semáforos para que a ordem dos prints das partes das tarefas respeitem o diagrama da figura (<strong>60% da nota</strong>)</p>
<p><strong>OBS</strong>:</p>
<ul>
<li>
<p>Você não deve introduzir novas dependências. Ou seja, se seu programa criar relações de dependência além das da figura, sua questão poderá não receber nota.</p>
</li>
<li>
<p>Não altere os <code>printf</code> existentes, nem adicione novos.</p>
</li>
</ul>
<h2>Questão 2 (2,5)</h2>
<p>Neste exercício, o programa <code>q2</code> recebe como argumento da linha de comando <strong>uma palavra</strong> e sua tarefa é fazer uma verificação da mesma.</p>
<p>Exemplo de como seu programa <code>q2</code> será chamado:</p>
<p><code>./q2 quadrado</code></p>
<p>Uma tarefa comum em programação de sistemas é <strong>integrar com outros programas</strong> instalados. Assim sendo, a palavra (no exemplo é <strong>quadrado</strong>) deverá ser examinada pelo programa <code>verify</code>, disponível de forma compilada para x86 na pasta da questão.</p>
<p>O programa <code>verify</code> retorna <code>-1</code> quando recebe uma chamada errada (quantidade de argumetos diferente de <code>1</code>), e valores de <code>0</code> a <code>4</code> inclusive. Você não precisa se preocupar com o significado de cada código retornado, apenas considere que a validação deve ser feita pelo verify e algum código deve ser retornado!</p>
<p>Entretanto, um problema é que as vezes as chamadas ao programa <code>verify</code> são interrompidas devido a sinais recebidos. Assim, você deve trabalhar no arquivo <code>q2.c</code> para:</p>
<ul>
<li>Criar um processo filho e nele, executar o <code>verify</code>, passando para o <code>verify</code> o primeiro argumento recebido pelo executável <code>q2</code> (<strong>30% da nota</strong>).</li>
<li>No proceso pai:<ul>
<li>Caso o processo filho TENHA finalizado normalmente, exiba a mensagem <code>VERIFY RETORNOU %d\n</code>, substituindo <code>%d</code> pelo retorno do <code>verify</code>. O processo pai deve sair retornando o mesmo valor devolvido por <code>verify</code> (<strong>30% da nota</strong>).</li>
<li>Caso o processo filho TENHA SIDO sinalizado, exiba a mensagem <code>VERIFY TEMINOU COM SINAL %s\n</code>, substituindo <code>%s</code> pelo texto que descreve o sinal.</li>
<li>Repita a chamada do <code>verify</code> (primeiro passo) até que ele finalize normalmente (<strong>40% da nota</strong>).</li>
</ul>
</li>
</ul>
<p><strong>Atenção</strong>:</p>
<ul>
<li>
<p>O executável <code>verify</code> também tem a chamada no padrão <code>./verify palavra</code></p>
</li>
<li>
<p>Imprima EXATAMENTE conforme solicitado, sem deixar espaços antes ou depois das frases. Dê apenas um <code>\n</code> ao final.</p>
</li>
</ul>
<p><strong>OBS</strong>:</p>
<ul>
<li>
<p>Trabalhe no arquivo <code>q2.c</code> e complete as partes faltantes</p>
</li>
<li>
<p>Compile com <code>gcc q2.c -o q2</code></p>
</li>
<li>
<p>Deixei um arquivo executável <code>q2_ref</code> que exemplifica o comportamento desejado do programa final (é um gabarito!). Teste, por exemplo, com <code>./q2_ref ferias</code> e utilize como referência!</p>
</li>
<li>
<p>O executável <code>verify</code> tem comportamento aleatório, então as vezes irá demorar mais para conseguir validar a palavra</p>
</li>
</ul>
<p><strong>Nesta questão você deverá usar as funções de gerenciamento de processos e chamada de executáveis vistas em aula. Você não pode, por exemplo, usar <code>system</code>.</strong></p>
<h2>Questão 3 (2,5)</h2>
<p>Abra o arquivo <code>q3.c</code>!</p>
<p>Uma nova funcionalidade foi requisitada nesta aplicação e você é o responsável por implementá-la: gerar log de inicialização e finalização do programa, de modo que quando o usuário desejar fechar a aplicação, isto seja registrado em um arquivo de texto.</p>
<p>Sua tarefa neste exercício é:</p>
<ul>
<li>
<p>Na <code>main</code>, exibir com <code>printf</code> o PID do processo (<strong>10% da nota</strong>)</p>
</li>
<li>
<p>Ao inicializar a aplicação com <code>./q3 logfile.log</code>, adicionar ao arquivo de log <code>logfile.log</code> uma nova linha contendo uma mensagem conforme o exemplo <code>08:15:03 ./q3 started\n</code>. Perceba que você deve incluir a hora, minutos e segundos do evento! Se o arquivo de log não existir, deve ser criado (<strong>30% da nota</strong>)</p>
</li>
<li>
<p>Ao receber um sinal <strong>SIGTERM</strong>, adicionar ao arquivo de log uma nova linha contendo uma mensagem conforme o exemplo <code>08:15:03 ./q3 finished\n</code> (<strong>35% da nota pelo registro do handler e pela mensagem no arquivo</strong>)</p>
</li>
<li>
<p>Ao receber um sinal <strong>SIGINT</strong>, exibir a mensagem na saída padrão e continuar normalmente (sem finalizar a aplicação): <code>Esta aplicacao nao fecha com SIGINT!\n</code> (<strong>15% da nota pelo registro do handler e pela mensagem na saída padrão</strong>)</p>
</li>
<li>
<p>Se o arquivo de log já existir, ele não deve ser sobrescrito. As mensagens de log são concatenadas ao seu final (<strong>10% da nota</strong>)</p>
</li>
</ul>
<p><strong>OBS</strong>:</p>
<ul>
<li>
<p>Você deve criar as funções para serem handlers dos sinais</p>
</li>
<li>
<p>Os Handlers devem ser registrados na <code>main</code></p>
</li>
<li>
<p>Perceba que o nome do arquivo de log é passado pela linha de comando, nem sempre será <code>logfile.log</code>.</p>
</li>
<li>
<p>Para os arquivos, utilize APENAS as chamadas vistas em aula: <code>open</code>, <code>close</code>, <code>read</code>, <code>write</code>. Não pode utilizar <code>fopen</code> por exemplo</p>
</li>
<li>
<p>Considere sempre a hora atual do sistema. Para trabalhar com as horas, consulte o manual: </p>
<ul>
<li><code>man 3 time</code></li>
<li><code>man 3 localtime</code></li>
<li>Veja o arquivo <code>q3_ref_horas.c</code>!</li>
</ul>
</li>
<li>
<p>Para testar, envie sinais pelo terminal e confira o arquivo de log gerado!</p>
</li>
</ul>
<h2>Questão 4 (2,5)</h2>
<p>No lab de processos vimos o quão necessário é saber manipular <strong>strings</strong> em <strong>C</strong>.</p>
<p>Neste exercício seu trabalho será criar uma função</p>
<p><code>char *extrair_arquivo(char *url)</code></p>
<p>que analisa a string <code>url</code> e retorna um ponteiro para <strong>UMA NOVA string</strong>, alocada <strong>dinamicamente</strong> contendo:</p>
<ul>
<li>O nome do arquivo apontado pela URL.</li>
</ul>
<p>Exemplos:</p>
<ul>
<li>
<p>Para a entrada <strong>http://www.google.com/icon.png</strong> você deve retornar um <code>char*</code> contendo <strong>icon.png</strong></p>
</li>
<li>
<p>Para a entrada <strong>ftp://receita.fazenda.gov.br/ir/2022/report1.pdf</strong> você deve retornar um <code>char*</code> contendo <strong>report1.pdf</strong></p>
</li>
</ul>
<p>Abra o arquivo <code>q4.c</code>, analise os testes e implemente a função acima. Sua nota será pela porcentagem de testes aprovados, considerando um total de quatro testes.</p>
<p>Para compilar:</p>
<p><code>gcc -Og -g q4.o extrair.c -o q4</code></p>
<p>Para rodar os testes automáticos:</p>
<p><code>./q4</code></p>
<p><strong>OBS</strong>:</p>
<ul>
<li>
<p>Você não pode nenhuma função da <code>string.h</code>. Ex: strlen, strcpy, strrchr, etc. Se utilizar, a questão será zerada.</p>
</li>
<li>
<p>Precisa funcionar para qualquer URL, se tiver testes fixos apenas para burlar os testes, irá zerar!</p>
</li>
</ul>